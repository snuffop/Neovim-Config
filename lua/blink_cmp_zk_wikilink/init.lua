-- lua/blink_cmp_zk_wikilink/init.lua
-- Blink source for ZK wikilinks: completes inside [[... to [[stem|Title]]]]

-- local M = {}
--
-- -- opts = { zk_cmd = "zk" }
-- function M.new(opts)
--   local self = setmetatable({}, { __index = M })
--   self.zk = (opts and opts.zk_cmd) or "zk"
--   return self
-- end
--
-- -- Only run in Markdown buffers
-- function M:enabled()
--   return vim.bo.filetype == "markdown"
-- end
--
-- -- Refresh on these chars
-- function M:get_trigger_characters()
--   return { "[", "|" }
-- end
--
-- -- Find the 0-based column of an open "[[" before cursor (unclosed).
-- local function open_wikilink_col(line, col0)
--   -- Consider text up to the cursor
--   local upto = line:sub(1, col0)
--   -- Case 1: ends with "[["
--   local pos = upto:match("()%[%[$")
--   if pos then return pos - 1 end
--   -- Case 2: last "[[" not yet closed by "]]"
--   -- We scan from the end for a "[[" that isn't followed by "]]" before cursor.
--   local last_open
--   local search_from = 1
--   while true do
--     local p = upto:find("%[%[", search_from, false)
--     if not p then break end
--     last_open = p
--     search_from = p + 2
--   end
--   if not last_open then return nil end
--   -- If there is a closing "]]" after that open within `upto`, it's closed
--   local after_open = upto:sub(last_open + 2)
--   if after_open:find("%]%]") then return nil end
--   return last_open - 1
-- end
--
-- -- Build [{ stem=..., title=..., path=... }, ...] from `zk list`
-- local function zk_rows(zk_cmd)
--   local rows = vim.fn.systemlist({ zk_cmd, "list", "--quiet", "--format", "{{path}}\t{{title}}" })
--   if vim.v.shell_error ~= 0 then return {} end
--   local out = {}
--   for _, r in ipairs(rows) do
--     local p, t = r:match("^(.-)\t(.*)$")
--     if p and p ~= "" then
--       local stem = vim.fn.fnamemodify(p, ":t:r")
--       t = (t ~= "" and t) or stem
--       table.insert(out, { stem = stem, title = t, path = p })
--     end
--   end
--   return out
-- end
--
-- function M:get_completions(ctx, cb)
--   local row0 = ctx.cursor[1] - 1
--   local col0 = ctx.cursor[2]
--   local line = vim.api.nvim_get_current_line()
--
--   local open_col = open_wikilink_col(line, col0)
--   if not open_col then return cb({ items = {} }) end
--
--   local tail = line:sub(open_col + 3)
--   local pipe_pos = tail:find("|", 1, true)
--   local clos_pos = tail:find("%]%]", 1)
--   if pipe_pos and col0 >= (open_col + 2 + pipe_pos) then return cb({ items = {} }) end
--   if clos_pos and col0 >= (open_col + 2 + clos_pos) then return cb({ items = {} }) end
--
--   local insert_start = { line = row0, character = open_col + 2 }
--   local insert_end   = { line = row0, character = col0 }
--
--   -- <<< NEW: detect if "]]" already sits right after the cursor >>>
--   -- Lua strings are 1-based; next two chars after cursor:
--   local next_two = line:sub(col0 + 1 + 1, col0 + 2 + 1)  -- (col0 is 0-based)
--   local close = (next_two == "]]") and "" or "]]"
--
--   local items = {}
--   for _, it in ipairs(zk_rows(self.zk)) do
--     local label = string.format("%s â€” %s", it.title, it.stem)
--     table.insert(items, {
--       label = label,
--       filterText = it.title .. " " .. it.stem,
--       textEdit = {
--         newText = string.format("%s|%s%s", it.stem, it.title, close),
--         insert  = { start = insert_start, ["end"] = insert_end },
--         replace = { start = insert_start, ["end"] = insert_end },
--       },
--       kind = require("blink.cmp.types").CompletionItemKind.Text,
--       labelDetails = { detail = "  " .. it.stem },
--     })
--   end
--
--   cb({ items = items, is_incomplete_backward = false, is_incomplete_forward = false })
-- end
--
-- return M

