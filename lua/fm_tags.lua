--
-- local M = {}
--
-- -- Small helpers ---------------------------------------------------------------
-- local function trim(s) return (s:gsub("^%s+", ""):gsub("%s+$", "")) end
-- local function dedupe_sorted(list)
--   local seen, out = {}, {}
--   for _, t in ipairs(list) do
--     t = trim(t)
--     if #t > 0 and not seen[t] then
--       seen[t] = true
--       table.insert(out, t)
--     end
--   end
--   table.sort(out)
--   return out
-- end
--
-- -- Frontmatter locate/parse/write ----------------------------------------------
-- -- Returns {start=lnum, stop=lnum, lines={...}} or nil (0-indexed line nums)
-- local function get_frontmatter(buf)
--   local n = vim.api.nvim_buf_line_count(buf)
--   if n == 0 then return nil end
--   local first = vim.api.nvim_buf_get_lines(buf, 0, 1, false)[1] or ""
--   if not first:match("^%-%-%-%s*$") then return nil end
--
--   for i = 1, math.min(n - 1, 5000) do
--     local line = vim.api.nvim_buf_get_lines(buf, i, i + 1, false)[1] or ""
--     if line:match("^%-%-%-%s*$") then
--       local lines = vim.api.nvim_buf_get_lines(buf, 0, i + 1, false)
--       return { start = 0, stop = i, lines = lines }
--     end
--   end
--   return nil -- unterminated frontmatter, bail
-- end
--
-- -- Parse tags from a slice of lines (frontmatter body lines only)
-- local function parse_tags_from_lines(lines)
--   -- Accept:
--   -- tags: [a, b, c]
--   -- tags:
--   --   - a
--   --   - b
--   local tags = {}
--
--   -- Find "tags:" line
--   local idx
--   for i, l in ipairs(lines) do
--     if l:match("^tags:%s*") then idx = i break end
--   end
--   if not idx then return tags, nil end
--
--   local line = lines[idx]
--   local inline = line:match("^tags:%s*%[(.*)%]%s*$")
--   if inline then
--     for t in inline:gmatch("[^,%s%]]+") do
--       table.insert(tags, t)
--     end
--     return tags, { kind = "inline", idx = idx }
--   end
--
--   -- Block list style: collect following indented "- xxx" lines
--   if line:match("^tags:%s*$") then
--     local i = idx + 1
--     while i <= #lines do
--       local l = lines[i]
--       if l:match("^%s*%-%s+") then
--         local t = trim(l:gsub("^%s*%-%s+", ""))
--         if #t > 0 then table.insert(tags, t) end
--         i = i + 1
--       else
--         break
--       end
--     end
--     return tags, { kind = "block", idx = idx }
--   end
--
--   -- Unknown format, treat as none
--   return {}, nil
-- end
--
-- -- Serialize tags back into lines, preferring block style for readability
-- local function set_tags_in_frontmatter_lines(lines, new_tags)
--   local body = vim.list_slice(lines, 2, #lines - 1) -- exclude first/last '---'
--   local header = lines[1]
--   local footer = lines[#lines]
--
--   local tags, loc = parse_tags_from_lines(body)
--   tags = new_tags -- overwrite with normalized
--
--   local out = {}
--
--   if loc == nil then
--     -- Insert new tags section near the top, after first real key if any
--     local inserted = false
--     for i, l in ipairs(body) do
--       if not inserted and l:match("^%w") then
--         table.insert(out, "tags:")
--         for _, t in ipairs(tags) do table.insert(out, ("  - %s"):format(t)) end
--         table.insert(out, l)
--         inserted = true
--       else
--         table.insert(out, l)
--       end
--     end
--     if not inserted then
--       -- empty body
--       out = { "tags:" }
--       for _, t in ipairs(tags) do table.insert(out, ("  - %s"):format(t)) end
--     end
--   else
--     -- Rebuild keeping surrounding keys
--     if loc.kind == "inline" then
--       for i, l in ipairs(body) do
--         if i == loc.idx then
--           if #tags == 0 then
--             -- remove the line entirely
--           else
--             -- convert to block style
--             table.insert(out, "tags:")
--             for _, t in ipairs(tags) do table.insert(out, ("  - %s"):format(t)) end
--           end
--         else
--           table.insert(out, l)
--         end
--       end
--     elseif loc.kind == "block" then
--       local i = 1
--       while i <= #body do
--         if i == loc.idx then
--           -- write new block (or remove if empty)
--           if #tags > 0 then
--             table.insert(out, "tags:")
--             for _, t in ipairs(tags) do table.insert(out, ("  - %s"):format(t)) end
--           end
--           -- skip old block: lines after "tags:" that start with "- "
--           i = i + 1
--           while i <= #body and body[i]:match("^%s*%-%s+") do i = i + 1 end
--         else
--           table.insert(out, body[i])
--           i = i + 1
--         end
--       end
--     end
--   end
--
--   local rebuilt = { header }
--   vim.list_extend(rebuilt, out)
--   table.insert(rebuilt, footer)
--   return rebuilt
-- end
--
-- -- Public API ------------------------------------------------------------------
-- function M.read_tags(buf)
--   buf = buf or 0
--   local fm = get_frontmatter(buf)
--   if not fm then return {} end
--   local body = vim.list_slice(fm.lines, 2, #fm.lines - 1)
--   local tags = parse_tags_from_lines(body)
--   return tags or {}
-- end
--
-- local function write_frontmatter(buf, new_lines)
--   -- Replace the existing frontmatter region (or insert at top if none)
--   local fm = get_frontmatter(buf)
--   if fm then
--     vim.api.nvim_buf_set_lines(buf, fm.start, fm.stop + 1, false, new_lines)
--   else
--     -- Insert new frontmatter at top
--     vim.api.nvim_buf_set_lines(buf, 0, 0, false, new_lines)
--     vim.api.nvim_buf_set_lines(buf, #new_lines, #new_lines, false, { "" })
--   end
-- end
--
-- local function ensure_frontmatter(buf)
--   local fm = get_frontmatter(buf)
--   if fm then return fm end
--   local lines = { "---", "---" }
--   vim.api.nvim_buf_set_lines(buf, 0, 0, false, lines)
--   return get_frontmatter(buf)
-- end
--
-- local function current_tags(buf)
--   buf = buf or 0
--   ensure_frontmatter(buf)
--   local fm = get_frontmatter(buf)
--   local body = vim.list_slice(fm.lines, 2, #fm.lines - 1)
--   local tags = parse_tags_from_lines(body)
--   return dedupe_sorted(tags or {}), fm
-- end
--
-- function M.add_tag(tag)
--   local buf = 0
--   tag = trim(tag or "")
--   if #tag == 0 then return end
--   local tags, fm = current_tags(buf)
--   table.insert(tags, tag)
--   tags = dedupe_sorted(tags)
--   local rebuilt = set_tags_in_frontmatter_lines(fm.lines, tags)
--   write_frontmatter(buf, rebuilt)
--   vim.notify(("Added tag: %s"):format(tag), vim.log.levels.INFO, { title = "Frontmatter" })
-- end
--
-- function M.remove_tag(tag)
--   local buf = 0
--   tag = trim(tag or "")
--   if #tag == 0 then return end
--   local tags, fm = current_tags(buf)
--   local out = {}
--   for _, t in ipairs(tags) do if t ~= tag then table.insert(out, t) end end
--   local rebuilt = set_tags_in_frontmatter_lines(fm.lines, dedupe_sorted(out))
--   write_frontmatter(buf, rebuilt)
--   vim.notify(("Removed tag: %s"):format(tag), vim.log.levels.INFO, { title = "Frontmatter" })
-- end
--
-- -- UX sugar: prompt + commands -------------------------------------------------
-- function M.prompt_add()
--   vim.ui.input({ prompt = "Add tag: " }, function(input)
--     if input then M.add_tag(input) end
--   end)
-- end
--
-- function M.prompt_remove()
--   -- show current tags to help memory-challenged future-you
--   local tags = M.read_tags(0)
--   vim.ui.select(tags, { prompt = "Remove tag:", kind = "frontmatter_tags" }, function(choice)
--     if choice then M.remove_tag(choice) end
--   end)
-- end
--
-- return M
